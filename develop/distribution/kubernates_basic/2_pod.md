# 概览

`Pod` 中封装着容器, 存储, 独立的网络IP, 容器运行策略. `Pod` 代表一个部署单位: `Kubernates` 中应用的一个实例, 可能由一个或多个容器组合在一起共享资源.

* 一个 `Pod` 中运行一个容器.
* 一个 `Pod` 中运行多个容器

`Pod` 中可以同时运行多个进程协同工作, 同一个 `Pod` 中的容器会自动的分配到同一个 `node` 上. 同一个 `Pod` 中的容器共享资源, 网络环境和依赖, 总是被同时调度.

注意在一个 `Pod` 中同时运行多个容器是一种比较高级的用法, 只有当容器需要紧密配合协作的时候才考虑用这种模式.

![[assert/Pasted image 20220627120910.png]]

`Pod` 中可以共享两种资源: 网络和存储.

**网络**

每个 `Pod` 会被分配唯一的IP地址, 其中的所有容器共享网络空间, 包括IP和端口. `Pod` 内部的容器可以使用 `localhost` 互相通信.

**存储**

`Pod` 中的所有容器都可以访问共享的 `Volume` , 也可以用来持久化 `Pod` 中的存储资源, 以防容器重启后文件丢失.

> 注意: 重启 `Pod` 中的容器跟重启 `Pod` 不是一回事, `Pod` 只提供容器的运行环境并保持容器的运行状态, 重启容器不会造成 `Pod` 重启.

`Pod` 不会自愈, 如果 `Pod` 运行的节点故障, 或者是调度器本身故障, 就会被删除. 如果所在的节点缺少资源或者 `Pod` 处于维护状态, `Pod` 也会被驱逐. `Kubernates` 使用更高级的成为 `Controller` 的抽象层来管理 `Pod` 实例.

**Controller**

* Deployment
* StatefulSet
* DaemonSet

通常, `Controller` 会用提供的 `Pod Template` 来创建相应的 `Pod`

# 解析

## 为什么不直接在一个容器中运行多个应用程序

1. 透明, 让 `Pod` 中的容器对基础设施可见, 以便基础设施能够为这些容器提供服务.
2. 解耦软件依赖, 每个容器都可以进行版本管理, 独立的编译和发布.
3. 使用方便, 用户不必运行自己的进程管理器.
4. 效率, 由基础架构提供更多的职责.

## 持久性

`Pod` 在设计之初就不是作为持久化实体的, 在调度失败, 节点故障, 缺少资源或者节点维护的状态下都会死掉被驱逐.

通常, 用户不需要手动直接创建 `Pod`, 而是应该使用 `Controller`, 即使是创建单个 `Pod` 的情况下. `Controller` 可以提供集群级别的自愈功能, 复制和升级管理.

