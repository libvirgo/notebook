分布式键值数据库, 用于共享配置和服务发现.

**使用 `etcd` 的场景默认处理的数据都是控制数据, 应用数据只用于数据量小但是更新访问频繁的情况**

# 场景

## 服务发现

* 强一致, 高可用的服务存储目录
* 注册服务和监控服务健康状态的机制
* 查找和连接服务的机制

### 具体场景

* 微服务协同工作架构中, 服务动态添加.
* `PaaS` 平台中应用多实例与实例故障重启透明化.

## 消息发布与订阅

* **应用中用到的一些配置信息放到里面进行集中管理** :: 应用在启动的时候主动获取一次配置, 同时, 在 `etcd` 节点上注册一个 `Watcher` 并等待, 以后每次配置有更新的时候都会通知订阅者, 以达到获取最新配置信息的目的.
* **分布式日志收集系统** :: 在 `etcd` 上创建一个以应用命名的目录, 并将这个应用的所有机器 `ip` 以子目录的形式存储到目录上, 然后设置一个 `etcd` 递归的 `watcher` 递归式的监控应用目录下所有信息的变动. 以实现机器消息变动的时候能够实时通知到收集器调整任务分配.
* **系统中信息需要动态自动获取与人工干预修改信息请求内容的情况** :: 以往是暴露出接口来获取一些运行时的信息, 引入 `etcd` 后就只需要将这些信息存放到指定的 `etcd` 目录, 然后通过 `HTTP` 接口在外部访问.

## 负载均衡

* `etcd` 分布式架构存储的信息访问支持负载均衡. 集群化后每个核心节点都可以处理用户的请求.
* **利用 `etcd` 维护一个负载均衡节点表** 因为 `etcd` 可以监控一个集群中多个节点的状态, 当有一个请求发过来后, 可以轮询式的把请求转发给存活着的多个状态.

## 分布式通知与协调

* 通过 `etcd` 进行低耦合的心跳检测.
* 完成系统调度 :: `Watcher` 机制通知变化.
* 完成工作进度汇报 :: 子任务定时将自己的进度写入到注册在 `etcd` 的某个临时目录.


## 分布式锁

* 保持独占即所有获取锁的用户最终只有一个可以得到, 为此 `etcd` 提供了一套实现分布式锁原子操作 `CAS` 的 `API`.
* 控制时序, 即所有想要获得锁的用户都会被安排执行, 但是获得锁的顺序也是全局唯一的, 同时决定了执行顺序. `etcd` 为此也提供了一套 `API`, 对一个目录建值时指定为 `POST` 动作, 这样 `etcd` 会自动在目录下生成当前最大的值位键, 存储这个新的值. 同时还可以使用 `API` 按顺序列出所有当前目录下的键值. 此时这些键的值就是客户端的时许, 而这些键中存储的值可以是代表客户端的编号.
	![[./assert/Pasted image 20220624141909.png]]
	
## 分布式队列

创建一个先进先出的队列保证顺序.

## 集群监控与 `Leader` 竞选

1. 使用 `Watcher` 机制进行监控
2. 节点可以设置 `TTL Key` 比如每个 `30s` 发送一次心跳使代表该机器存活的节点继续存在, 否则消失

# 架构

![[./assert/Pasted image 20220624142202.png]]

* `HTTP Sefver`: 处理 `API` 以及其它节点的同步与心跳请求.
* `Store`: 用于处理 `etcd` 支持的各类功能的事务, 包括数据索引, 节点状态变更, 监控与反馈, 事件处理与执行等等.
* [[raft]]
* `WAL`: `Write Ahead Log`, 是 `etcd` 的数据存储方式. 通过该方式进行持久化. `WAL` 中, 所有数据提交前都会事先记录日志.